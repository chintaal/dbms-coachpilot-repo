# Database Schema Management

## Source of Truth

The database schema is managed through migrations and generated TypeScript types:

- **Migrations**: `supabase/migrations/*.sql`
  - All database schema changes should be captured here
  - Run `npm run sb:pull` to sync changes from Supabase Cloud
  - Migrations are versioned by timestamp

- **Generated Types**: `src/types/supabase.ts`
  - **DO NOT edit this file manually** - it is auto-generated
  - Run `npm run sb:types` to regenerate after schema changes
  - Use `npm run sb:sync` to pull schema and regenerate types in one command

## Workflow

### After making changes in Supabase Cloud Dashboard:

```bash
cd frontend
npm run sb:sync
```

This will:
1. Pull the latest schema from Supabase Cloud (`supabase db pull`)
2. Generate TypeScript types (`supabase gen types typescript --linked`)

### Using Types in Code

Import the `Database` type from the generated types:

```typescript
import { Database } from '@/types/supabase'
import { createClient } from '@/lib/supabase/server'

const supabase = await createClient()
// supabase is now typed with your database schema
```

## RLS-First Approach

- Row Level Security (RLS) is enabled by default
- Always use the `anon` key (via `NEXT_PUBLIC_SUPABASE_ANON_KEY`)
- Never use `service_role` key on the client side
- For privileged operations, use server actions or route handlers

## User-Owned Tables Pattern

Tables that belong to users should follow this pattern:

```sql
create table profiles (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id) not null unique,
  -- other columns...
);

-- Enable RLS
alter table profiles enable row level security;

-- Policy: Users can only see their own profile
create policy "Users can view own profile"
  on profiles for select
  using (auth.uid() = user_id);

-- Policy: Users can only update their own profile
create policy "Users can update own profile"
  on profiles for update
  using (auth.uid() = user_id);
```

This ensures:
- Each row is tied to a user via `user_id`
- RLS policies automatically filter data by `auth.uid()`
- Users can only access their own data

## Phase 1 Tables

### profiles
User profiles (one-to-one with auth.users)
- `id` (uuid, PK, references auth.users)
- `full_name` (text)
- `created_at` (timestamptz)

### decks
Flashcard decks
- `id` (uuid, PK)
- `user_id` (uuid, references auth.users)
- `title` (text)
- `description` (text)
- `created_at`, `updated_at` (timestamptz)

### notes
Source notes for cards (for future AI processing)
- `id` (uuid, PK)
- `user_id` (uuid, references auth.users)
- `source_type` (text)
- `raw_text` (text)
- `created_at` (timestamptz)

### cards
Flashcard content
- `id` (uuid, PK)
- `user_id` (uuid, references auth.users)
- `deck_id` (uuid, references decks)
- `note_id` (uuid, references notes, nullable)
- `front` (text)
- `back` (text)
- `tags` (text[])
- `created_at`, `updated_at` (timestamptz)

### card_state
Spaced repetition state
- `card_id` (uuid, PK, references cards)
- `user_id` (uuid, references auth.users)
- `due_at` (timestamptz)
- `interval_days` (int)
- `ease_factor` (numeric)
- `reps` (int)
- `lapses` (int)
- `last_reviewed_at` (timestamptz, nullable)

### reviews
Review history log
- `id` (uuid, PK)
- `user_id` (uuid, references auth.users)
- `card_id` (uuid, references cards)
- `rating` (int, 0=again, 1=hard, 2=good, 3=easy)
- `reviewed_at` (timestamptz)
- `prev_due_at`, `next_due_at` (timestamptz)
- `prev_interval_days`, `next_interval_days` (int)
- `prev_ease_factor`, `next_ease_factor` (numeric)

### quiz_sessions
Quiz session metadata
- `id` (uuid, PK)
- `user_id` (uuid, references auth.users)
- `deck_id` (uuid, references decks)
- `mode` (text)
- `total` (int)
- `correct` (int)
- `started_at`, `ended_at` (timestamptz)

### quiz_items
Individual quiz answers
- `id` (uuid, PK)
- `session_id` (uuid, references quiz_sessions)
- `card_id` (uuid, references cards)
- `is_correct` (boolean)
- `answered_at` (timestamptz)

## Database Functions

### apply_review(card_id uuid, rating int)
Atomically applies a review rating:
- Updates `card_state` with new interval, ease_factor, reps, lapses, due_at
- Inserts a record into `reviews` table
- Returns JSONB with updated state

Rating values:
- 0 = Again (reset, penalize)
- 1 = Hard (reduce interval/ease)
- 2 = Good (normal progression)
- 3 = Easy (increase interval/ease)

## Indexes

Key indexes for performance:
- `decks(user_id)`
- `cards(user_id, deck_id)`
- `card_state(user_id, due_at)` - critical for review queue
- `card_state(user_id, due_at) WHERE due_at <= now()` - partial index for active reviews
- `reviews(user_id, card_id, reviewed_at desc)`
